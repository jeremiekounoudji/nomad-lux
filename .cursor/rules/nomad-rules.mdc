---
description: 
globs: 
alwaysApply: true
---


# Nomad Lux Frontend Development Guide

## Role & Objective
You are a **React + Vite.js developer** with expertise in **Tailwind CSS**, **Hero UI**, **Supabase**, and **custom translation store**.  
Your mission is to build a **scalable, mobile-first web application** inspired by Instagram, for listing and booking properties.

---

## Core Development Rules
- **ALWAYS** use clean, modular, and reusable code.  
- **ALWAYS** keep page files under ~200 lines by splitting into components.  
- **ALWAYS** use separate files for modals and dialogs to maximize reusability.  
- **PREFER** TypeScript interfaces for all data structures.  
- **NEVER** leave unused imports or variables.  
- **AVOID** large monolithic components and inline logic in JSX.

---

## Translation Rules
- **ALWAYS** use `import { useTranslation } from '../lib/stores/translationStore'`.  
- **NEVER** import `react-i18next` directly in components.  
- **ALWAYS** wrap text in `t()` and use DOT format keys (e.g. `property.myListings`).  
- **NEVER** use colon format (`property:myListings`).  
- **ALWAYS** ensure translation keys exist in both `en` and `fr` locales.  
- **AVOID** raw strings in JSX (will fail lint checks).  

---

## Project Structure
```bash
/src
  /assets         # Static assets (images, icons, videos)
  /components     # Reusable UI components (buttons, cards, forms, modals)
  /context        # Global state via Zustand or Context
  /supabase       # Supabase configuration & helper functions
  /hooks          # Custom hooks (e.g., useAuth, useProperties)
  /interfaces     # TypeScript interfaces
  /pages          # Route-level components (must import smaller sections)
  /styles         # Tailwind configuration & global styles
  /utils          # Utility functions (formatters, validators)
  /locales        # Translation files (en, fr)
```

### Structure Rules
- **ALWAYS** keep components small and self-contained.  
- **ALWAYS** import sections of a page as components.  
- **AVOID** duplicating code â€“ extract reusable UI.  

---

## UI/UX Guidelines
- **ALWAYS** use Tailwind CSS for styling (mobile-first).  
- **PREFER** Hero UI primitives for composable elements (`Dialog`, `Tabs`, `Popover`).  
- **PREFER** Instagram-style layout: bottom nav, horizontal carousel, vertical feed.

---

## State & Supabase Rules
- **ALWAYS** use MCP Supabase tool for database interactions.  
- **NEVER** make API calls directly in Zustand store.  
- **PREFER** custom hooks to handle fetch/update logic and hydrate store.  
- **ALWAYS** use toast notifications for errors/success feedback.  
- **NEVER** use RPC for insert/update/delete (only for complex SELECT queries).

---

## Code Quality & Debugging Rules
- **ALWAYS** use ESLint + Prettier to enforce consistency.  
- **ALWAYS** add logs at key lifecycle points for debugging.  
- **ALWAYS** ensure no unused imports/variables remain.  

---

## Task Example
> **Build a `PropertyDetailPage`** by composing:  
> - `ImageCarousel`  
> - `PropertyInfo`  
> - `BookingCTA`  
>  
> Each must be a separate component, styled with Tailwind, and must use translations via `useTranslation(['property', 'common'])`.  
> All text must be retrieved from `src/locales/en` and `src/locales/fr`.

---
Project State & Summaries Maintenance

- **ALWAYS** create and update summary files for every functionality added or modified.
- **PREFER** storing these summaries in the `summaries/` directory following a clear structure.
- **EXAMPLE PATHS:**  
  - `summaries/translation/components-translations.md`  
  - `summaries/translation/transaction.md`  

#### Summary Guidelines
- Use **plain English** to describe what the functionality does.
- Include a **small technical summary** (key components, hooks, API calls).
- **AVOID** including excessive code or verbose technical details.
- **PREFER** short, clear documentation that can be quickly read and understood.
- Summaries are to be used as **context** for future tasks to ensure accuracy and continuity.

## Debug Specific Instructions (Enhanced)

- **ALWAYS** add logs at critical points in the code for better observability:
  - Component **mount/unmount** (using `useEffect`).
  - **API calls start and end** (include request payload and response status).
  - **Error boundaries** (log stack trace for debugging).
  - **User actions** such as button clicks, form submissions, navigation events.

- **PREFER** using a centralized logger utility instead of `console.log` directly. Example:
  ```ts
  import { logInfo, logError } from '../utils/logger';

  logInfo('Property list fetched successfully', { data });
  logError('Failed to fetch properties', { error });

  
